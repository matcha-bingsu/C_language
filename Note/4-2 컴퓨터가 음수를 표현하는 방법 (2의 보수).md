# 4-2 컴퓨터가 음수를 표현하는 방법 (2의 보수)

- 2의 보수 표현법
- 정수 오버플로우란?

### 2의 보수 표현법

7을 이진수로 표현한 0111에서 0000이 되도록 하는 이진수는 1001이다. 왜냐하면 `0111` 과 `1001` 을 더하면 `10000` 이 되는데, CPU 가 4 비트만 기억하므로 맨 앞에 1 은 버려져서 그냥 `0000` 이 되기 때문이지요.

이렇게 덧셈을 고려하였을 때 가장 자연스러운 방법으로 **음수를 표현하는 방식을 바로 2 의 보수 표현이라고 합니다.** **2 의 보수 표현 체계 하에서** 어떤 수의 부호를 바꾸려면 **먼저 비트를 반전 시킨 뒤에 1 을 더하면 됩니다.**

예를 들어서 -7 을 나타내기 위해서는, 7 의 이진수 표현인 `0111` 의 비트를 모두 반전시키면 `1000` 이 되는데 여기다 1 을 더해서 `1001` 로 표현하면 됩니다. 반대로 -7 에서 7 로 가고 싶다면 `1001` 의 부호를 모두 반전 시킨뒤 (0110) 다시 1 을 더하면 양수인 7 (0111) 이 나오게 됩니다.

이 체계에서 중요한 점은 `0000` 의 2 의 보수는 그대로 `0000` 이 된다는 점입니다. 왜냐하면 `0000` 을 반전하면 `1111` 이 되는데, 다시 1 을 더하면 `0000` 이 되기 때문이죠!

또한 **어떤 수가 음수 인지 양수인지 판단하는 방법**도 매우 쉽습니다. 그냥 맨 앞 비트가 부호 비트라고 생각하면 됩니다. **예를 들어서 `1101` 의 경우 맨 앞 비트가 1 이기 때문에 음수 입니다. 따라서 이 수가 어떤 값인지 알고싶다면 보수를 구한 뒤에 (1101 --> 0010 --> 0011) - 만 붙여주면 되겠죠. `0011` 이 3 이므로, `1101` 은 경우 -3 이 됩니다.**

한 가지 재미있는 점은 2 의 보수 표현법에서 음수를 한 개더 표현할 수 있습니다. 왜냐하면 `1000` 의 경우 음수 이지만 변환 시켜도 다시 `1000` 이 나오기 때문이죠 (1000 --> 0111 --> 1000) 실제로 `int` 의 범위를 살펴보면 -2,147,483,648 부터 2,147,483,647 까지 이죠. 음수가 1 개 더 많습니다.

```python
int a = 2147483647; //0x7FFFFFFF
printf("a : %d \n", a);

a++;
printf("a : %d \n", a);
```

우리는 a 의 현재 값이 `int` 가 보관할 수 있는 최대값이므로 1을 더 증가 시킨다면 오류를 내뿜게하거나 아니면 그냥 현재 값 그대로 유지하게 하고 싶었을 것입니다.

하지만 CPU 는 그냥 `0x7FFFFFFF` 값을 1 증가 시킵니다. 따라서 해당 `a++` 이후에 a 에는 `0x80000000` (이진수로 `1000 0000 ... 0000`) 이 들어가겟죠. 문제는 `0x80000000` 을 2의 보수 표현법 체계하에서 해석한다면 반전 하면 (`0111 1111 ... 1111`) 이 되고 다시 1 을 더하면 (`1000 0000 ... 0000`) 이 되므로 `0x80000000,` 즉 -2147483648 이 됩니다.

따라서 위와 같이 양수에 1 을 더했더니 음수가 나와버리는 불상사게 생기게 되죠. 이와 같이 자료형의 최대 범위보다 큰 수를 대입하므로써 발생하는 문제를 **오버플로우(overflow)** 라고 하며, C 언어 차원에서 오버플로우가 발생하였다는 사실을 알려주는 방법은 없기 때문에 여러분 스스로 항상 사용하는 자료형의 크기를 신경 써줘야만 합니다!

<aside>
💡 한 바이트에 저장 가능한 값의 범위: 0 ~ 255 (2의 8승)

</aside>

### 음수가 없는 자료형

`unsigned int` 의 경우 음수가 없고 0 부터 4294967295 까지의 수를 표현할 수 있습니다. `unsigned int` 가 양수만 표현한다고 해서 `int` 와 다르게 생겨먹은 것이 아닙니다. `unsigned int` 역시 `int` 와 같이 똑같이 `32` 비트를 차지 합니다.

다만, `unsigned int` 의 경우 `int` 였으면 2 의 보수 표현을 통해 음수로 해석될 수를 그냥 양수라고 생각할 뿐이지요. **→**

예를 들어 -1이 입력된다면 111 1111 ... 1111이 메모리에 저장되는데, 이는 음수를 나타내는 수는 단순히 -1로 저장하겠지만 음수가 없는 수는 1 + 2 + 4 + 8 + 16 + 32 + ...이 되어서 그냥 양수로 해석을 한다는 것입니다.

따라서 `unsigned int` 에 예를 들어서 `1` 을 대입하게 되면, `1` 은 `0xFFFFFFFF` 로 표현되니까,

```python
#include <stdio.h>

int main() {
	unsigned int b = -1;
	printf("b에 들어있는 값을 unsigned int로 해석했을 때의 값: %u \n", b);

	return 0;
}
```

![Untitled](4-2%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%20be541/Untitled.png)

물론 `unsigned int` 상에서도 **오버플로우**가 발생하지 않으라는 법이라는 없습니다

```python
#include <stdio.h>

int main() {
	unsigned int b = 4294967295;
	printf("b : %u \n", b);
	
	b++;
	printf("b : %u \n", b);
	return 0;
}
```

![Untitled](4-2%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%20be541/Untitled%201.png)

와 같이 나옵니다. 즉, `b` 에 `0xFFFFFFFF` (`1111 1111 ... 1111`) 이 들어가 있다가 1 증가함으로써 (`1 0000 ... 0000`) 이 되었는데 앞서 이야기 하였듯이 자료형의 크기를 초과하는 비트는 그대로 버려지므로 그냥 0 (`0000 0000 ... 0000`) 으로 해석된 것입니다.

![Untitled](4-2%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%20be541/Untitled%202.png)