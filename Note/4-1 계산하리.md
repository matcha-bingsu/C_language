# 4-1 계산하리

### 1. 산술연산자(Arithmetic Operator): ＋, －, *, /, %

`%` 라는 연산자에 대해 살펴봅시다. `+, -, *, /` 연산자는 모두 정수, 실수형 데이터에 대해서 모두 연산이 가능한데, **`%` 는 오직 정수형 데이터에서만 연산이 가능합니다.** 왜냐하면 `%` 는 나눈 나머지를 표시하는 연산자 이기 때문이죠. `a % b` 는 `a` 를 `b` 로 나눈 나머지를 표시합니다. 즉, `10 % 3 = 1` 이 됩니다.

```python
printf("a %% b 는 : %d \n \n", a % b)
```

위에서 `%%` 는 `%` 를 '표시'하기 위한 방법입니다. 왜냐하면 `%` 하나로는 `%d , %f` 같이 사용될 수 있기 때문이 표시가 되지 않습니다.

<**연산시 자료형 주의>**

**1)**

`%f` 가 오직 실수형 데이터 만을 출력하기 위해 있는 것이라 하였습니다. 그런데, `a / b` 가 10 나누기 3 이므로 3.3333... 이 되서 해서 실수형 데이터가 되는 것이 아닙니다.

`(정수형 변수) (연산) (정수형 변수)` 는 언제나 `(정수)` 으로 유지됩니다. 따라서, 실수형 데이터를 출력하는 `%f` 를 정수형 값 출력에 사용하면 위와 같이 이상한 결과가 나오게 됩니다.

**2)**

`a` 는 정수형 변수, `b` 는 실수형 변수 입니다. 그런데, 이들에 대해 연산을 한 후에 결과를 실수형으로 출력하였는데 정상적으로 나왔습니다. 그 것은 왜 일까요? 이는 컴파일러가 **산술 변환** 이라는 과정을 거치기 때문입니다. 즉, 어떠한 자료형이 다른 두 변수를 연산 할 때, 숫자의 범위가 큰 자료형으로 자료형들이 바뀝니다.

```python
1)
#include <stdio.h>
int main() {
	int a, b;
	a = 10;
	b = 3;
	printf("a / b 는 : %f \n", a / b);
	return 0;
}

2)
#include <stdio.h>
int main() {
	int a;
	double b;

	a = 10;
	b = 3;
	printf("a / b 는 : %f \n", a / b);
	printf("b / a 는 : %f \n", b / a);
	return 0;
}
```

### 2. 대입연산자(Assignment Operator): =

컴파일러는 ‘=’라는 기호는 뒤에서부터 해석합니다. 따라서 

```python
1)
a = 5;
b = 5;
c = 5;
d = 5;

2)
a = b = c = d = 5;
```

1)과 2)는 동일하게 해석됩니다. 2)의 경우, ‘d = 5’를 이해하고 이후 `c = d, b = c, a = b` 로 차례대로 해석해 나가기 때문에 `a = 5; b = 5; c = 5; d = 5;` 라는 문장과 같은 것이지요.

- 연산자 우선순위
- 복합 대입연산: +=, -=, *=, /=
- 증감연산자: ++, —

참고로, 위 4 개의 연산 중에서 가장 빨리 연산되는 것은 `a++` 과 같은 증감 연산입니다. 왜냐하면, a = a + 1 의 경우 ADD a 1 로 하지만, a++ 은 INC a 로 좀 더 빨리 계산된다.

### 3. 비트 연산자

이 연산자들은 정말 비트(bit) 하나 하나에 대해 연산을 합니다. 비트는 컴퓨터에서 숫자의 최소 단위로 1 비트는 0 혹은 1 을 나타내죠. 쉽게 말해 이진법의 한 자리라 볼 수 있습니다.

보통, 8개의 비트(8 bit) 를 묶어서 1 바이트(byte) 라고 하고, 이진법으로 8 자리 수라 볼 수 있습니다. 따라서, 1 바이트로 나타낼 수 있는 수의 범위가 0 부터 11111111 로 십진수로 바꾸면 0 부터 255 까지 나타낼 수 있습니다.

비트 연산자에는 `&` (And 연산), `|` (\ 위에 있는 것. 영문자 `i` 의 대문자가 아닙니다. Or 연산), `^` (XOR 연산), `<<, >>` (쉬프트 연산) , `~` (반전) 등이 있습니다. 일단, 각 연산자가 어떠한 역할을 하는지 살펴보도록 합시다.

**1) AND연산자 (&)**

[AND](https://modoocode.com/and) 연산은 아래와 같은 규칙으로 연산됩니다.

![Untitled](4-1%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A1%E1%86%AB%E1%84%92%20bb50a/Untitled.png)

**2) OR연산자 (|)**

[OR](https://modoocode.com/or) 연산은 [AND](https://modoocode.com/and) 연산과 대조적입니다. 어느 하나만 1 이여도 모두 1 이 되는데, 예를들어 `1101 | 1000` 은 결과가 1101 이 됩니다.

![Untitled](4-1%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A1%E1%86%AB%E1%84%92%20bb50a/Untitled%201.png)

**3) XOR연산자(^)**

[XOR](https://modoocode.com/xor) 연산은 특이하게도 두 수가 달라야지만 1 이 됩니다. 예를들어, `1100 ^ 1010` 의 경우 결과가 0110 이 됩니다. 마치 두 비트를 더한 다는 식으로 생각하시면 됩니다.

![Untitled](4-1%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A1%E1%86%AB%E1%84%92%20bb50a/Untitled%202.png)

**4) 반전연산자 (~)**

반전연산은 간단히 말에 0 을 1 로 1 을 0 으로 바꿔주는 것입니다. 예를들어서 `~1100` 을 하면 그 결과는 0011 이 됩니다.

**5) <<연산 (쉬프트 연산)**

위 연산 기호에서 느껴지듯이 비트를 왼쪽으로 쉬프트(Shift) 시킵니다. 예를 들어, 101011 를 1 만큼 쉬프트 시키면 ( 이를 `a << 1` 이라 나타냅니다)

아래 연산의 결과는 010110 이 됩니다. 이 때, `<<` 쉬프트 시, 만일 앞에 쉬프트된 숫자가 갈 자리가 없다면, 그 부분은 버려집니다. 또한 뒤에서 새로 채워지는 부분은 앞에서 버려진 숫자가 가는 것이 아니라 무조건 0 으로 채워집니다.

![Untitled](4-1%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A1%E1%86%AB%E1%84%92%20bb50a/Untitled%203.png)

**6) >>연산 (쉬프트 연산)**

이는 위와 같은 종류로 이는 `<<` 와 달리 오른쪽으로 쉬프트 해줍니다. 이 때, 오른쪽으로 쉬프트 하되, 그 숫자가 갈 자리가 없다면 그 숫자는 버려집니다. 이 때, 무조건 0 이 채워지는 `<<` 연산과는 달리 앞부분에 맨 왼쪽에 있었던 수가 채워지게 되죠. 예를들어서 `11100010 >> 3 = 11111100` 이 되고, `00011001 >> 3 = 00000011` 이 됩니다.

```python
#include <stdio.h>

int main(){
    int a = 0xAF; // 10101111
    int b = 0xB5; // 10110101

    printf("%x \n", a & b); // a & b = 10100101
    printf("%x \n", a | b); // a | b =10111111
    printf("%x \n", a ^ b); // a ^ b = 00011010
    printf("%x \n", ~a);    // ~a = 1....1 01010000
    printf("%x \n", a << 2);// a << 2 = 1010111100
    printf("%x \n", a >> 3);// b >> 3 = 00010110

    return 0;
}
```

![Untitled](4-1%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A1%E1%86%AB%E1%84%92%20bb50a/Untitled%204.png)

`int` 형 변수에 대한 설명을 보니 옆에 **Size** 이라 표시된 것이 있습니다. 이는 `int` 형 변수의 크기를 나타내는데 4 바이트라고 되어 있군요. 맞습니다. `int` 형 변수는 하나의 데이터를 저장하기 위하여 메모리 상의 4 바이트 - 즉 32 비트를 사용합니다. (1 byte = 8 bits) 아까, 하나의 비트가 0 과 1 을 나타낸다고 했으므로 (즉 1 개의 비트가 2 진수의 한 자리를 나타내게 되죠), 하나의 `int` 형 변수는 32 자리의 이진수라고 볼 수 있습니다. 예를들어 우리가 `a = 1` 이라 한 것은 실제로 컴퓨터에는 `a = 00000000 00000000 00000000 00000001` 이라 저장되는 것과 같게 되는 거죠.

즉, 우리가 `int a = 0xAF;` 라고 한 것은 `a = 10101111;` 이 맞지만 사실 컴퓨터 메모리 상에서는 `a` 가 `int` 형이기 때문에 `a = 00000000 00000000 00000000 10101111` (`10101111` 앞에 0 이 24 개 있다) 이라 기억하는 것이 됩니다. 따라서, 이 숫자를 반전 시키게 되면 `a = 11111111 11111111 11111111 01010000`, 즉 `0xFFFFFF50` 이 되는 것이지요. 마찬가지로 생각해 보면,

이 두 문장도 사실은 각각 `00000000 00000000 00000000 10101111` 과 `00000000 00000000 00000000 10110101` 을 쉬프트 연산한 것과 같습니다.

따라서 `a` 의 경우 `00000000 00000000 00000000 10101111` 을 왼쪽으로 2 칸 쉬프트 하면 `00000000 00000000 00000010 10111100` 이 되어 `0x2BC` 가 됩니다

`b` 의 경우 마치 앞에 1 이 있는 것 같지만 실제로는 `int` 형 데이터에 저장되어 있으므로 4 바이트로, `00000000 00000000 00000000 10110101` 이므로 맨 왼쪽의 비트는 0 입니다. 따라서 쉬프트를 하게 되면 왼쪽에 0 이 채워지면서 `00000000 00000000 00000000 00010110` 이 되어 `0x16` 이 됩니다.

- **복잡한 연산**

컴퓨터에도 연산을 하는데 무엇을 먼저 연산을 할 지 우선 순위가 정해져 있을 뿐더러 연산 방향 까지도 정해져 있습니다. 이를 간단히 살펴 보자면 아래와 같습니다.

![Untitled](4-1%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A1%E1%86%AB%E1%84%92%20bb50a/Untitled%205.png)

이와 같이 순위가 매겨져 있습니다. 이 때, 눈여겨 보아야 할 점은 괄호들이 제 1 우선 순위에 위치하였다는 점 입니다. 따라서, 어떠한 연산이라도 괄호로 감싸 주게 되면 먼저 실행 됩니다.

마지막으로, 결합 순위에 대해 잠시 다루어 보도록 하겠습니다. 표의 오른쪽을 보면 결합 순위가 나와 있는데, 대부분이 '왼쪽 우선' 이지만 몇 개는 '오른쪽 우선' 입니다. 이 말이 뜻하는 바가 무엇이냐면, 아래와 같은 문장을 수행할 때 계산하는 순위를 이야기 합니다.

![Untitled](4-1%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A1%E1%86%AB%E1%84%92%20bb50a/Untitled%206.png)

![Untitled](4-1%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A1%E1%86%AB%E1%84%92%20bb50a/Untitled%207.png)